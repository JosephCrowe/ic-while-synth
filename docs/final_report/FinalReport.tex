\documentclass[a4paper,twoside,notitlepage]{article}

\usepackage{parskip}
\usepackage{hyperref}
\usepackage[numbib]{tocbibind}
\usepackage[fleqn]{amsmath}
\usepackage{qtree}
\usepackage{float}
\usepackage{fancyvrb}

\floatstyle{boxed}
\restylefloat{figure}
\renewcommand{\bibsection}{\section{\bibname}}
\newcommand{\ttt}{\texttt}
\newcommand{\trm}{\textrm}

\begin{document}

\title{Synthesis of Simple While Programs Using Answer Set Programming}
\author{Joseph Crowe \\ Supervised by Krysia Broda and Mark Law}
\maketitle
\clearpage

\section*{Abstract}
\textbf{To be completed.}

\section*{Acknowledgements}
\textbf{To be completed.}

\clearpage

\tableofcontents

\section{Introduction}

One of the aims of computer science is to make it easier for people to 
generate \emph{computer programs}, which are the machine-readable 
representations of desired behaviour executed by a computer in order to 
perform some useful computation.

This project concerns the generation of \emph{imperative} computer 
programs, consisting of sequences of instructions to be executed in order, 
which are relatively easy to compile into a form that can be executed on 
most computing devices without further processing.

In particular, we restrict our attention to a \emph{simple while language} 
containing the minimal features for computation involving whole numbers: 
branching, using \emph{if statements}; looping, using \emph{while loops}, 
and some basic arithmetic operators such as addition and multiplication. 
See Section~\ref{sec:whilan} for a formal description of this language.

An example of such a program is:
\begin{Verbatim}[samepage=true]
    y = 1;
    while (x > 0) {
       y = y * 2;
       x = x - 1;
    }
\end{Verbatim}
If we denote by $x$ the initial value of the variable \texttt{x} 
(non-negative) and by $y$ the final value of \texttt{y} after running this 
program, we can see that its effect is to double a value starting at 1, 
$x$ times, $x$ and leave the result in $y$, or in other words to compute 
the $x$th power of two, $y = 2^x$.

We now have a way to instruct a computer to calculate the powers of two, 
but is it necessary for a person to write out the program in full? It 
might be easy in this case, but for more complicated programs this can be 
time-consuming, error prone, and dependent on specialised knowledge.

Lacking the inclination to write a program in the above form, we might 
wish instead to specify its behaviour as mathematical relation between 
its input and output variables, such as $y = 2^x$; or perhaps we do not 
even have a mathematical expression in mind, but simply wish to provide a 
list of examples of what the program should do:
\begin{center}
\begin{tabular}{| l || r | r | r | r | r | r |}
    \hline
    $x$ & 0 & 1 & 2 & 3 & 4  &  5 \\
    \hline
    $y$ & 1 & 2 & 4 & 8 & 16 & 32 \\
    \hline
\end{tabular}
\end{center}

The objective of this project is to provide automatic programming tools 
that address this problem by allowing a program to be generated from a 
list of input/output examples it is desired to satisfy, or from a 
mathematical or logical relation which is desired to hold over the whole 
domain of input/output values.
\clearpage

There is a significant body of previous work in the automatic synthesis of 
programs (see Section~\ref{sec:bkgsyn}). Most can be classified as 
\emph{inductive}, which take a machine-learning approach to generalising a 
set of input/output examples with a program in a particular language; or 
\emph{deductive}, which seek to construct a program which provably 
satisfies a high-level representation of desired behaviour.

There have been recent successes in inductive program synthesis, which 
have inspired this project to take an inductive approach to generating 
imperative programs; however, the problem in its full generality is far 
from solved, and with the application of new tools and techniques, we hope 
to break new ground and document their effectiveness.

In particular, we use a type of logic programming called Answer Set 
Programming (see Section~\ref{sec:bkgasp}), which was previously used for 
inductive synthesis of logic programs, as the main part of a system 
capable of inductively synthesising imperative programs.

\subsection{Contributions}
We present a tool which, given a list of input/output examples over a 
given variable domain and a declarative specification of the types of 
programs to consider (see Section~\ref{sec:spclng}), will generate a 
program (if one exists, given the language constraints) which satisfies 
all of the examples. See Section~\ref{sec:synexm}.

Furthermore, we extend this with the ability to accept a program skeleton 
delimited by preconditions, postconditions, midconditions and loop 
invariants, given as logical formulae relating the initial and current 
values of program variables. In this case, the user does not need to 
supply any input/output examples, as they are generated from the formulae 
as needed. See Section~\ref{sec:synfrm}.
\clearpage

\section{Background: Automatic Program Synthesis} \label{sec:bkgsyn}
\textbf{To be expanded.}

Saurabh Srivastava, Sumit Gulwani, et al.\ in 2010 showed\cite{popl10syn} 
that, given a functional specification of an imperative program, relating 
its inputs and outputs with logical formulae, and given also the looping 
structure of the the program, it is possible to infer a program satisfying 
these constraints, using techniques previously used for program 
verification.

David Perelman, Sumit Gulwani, et al.\ in 2014 developed a system\cite{tds} 
based on the principle of ``programming by example,'' which generates and 
iteratively refines a program from a sequence of increasingly more general 
sets of input/output examples. Notably, their system is not limited to 
imperative programs, but allows arbitrary domain-specific languages to be 
defined and used with the system.

\section{Background: Answer Set Programming} \label{sec:bkgasp}
Answer Set Programming (ASP) is a form of logic programming particularly 
suited to search problems over large domains (such as the domain of all 
imperative programs of a given length). An Answer Set Program distinguishes 
the result to be computed by a set of propositional facts and rules in the 
domain. Importantly, ASP includes \emph{aggregates}, \emph{integrity 
constraints}, and \emph{negation as failure}, where a rule can be conditional 
on the inability of prove that some proposition is true, which allows 
\emph{non-monotonic reasoning}. The result of running an ASP is an 
\emph{answer set} of facts which is consistent with the program, forms a 
\emph{stable model}, and is minimal in a certain sense. For further details, 
see \cite{glimpse}, which gives a concise introduction to the paradigm.

\subsection{Definitions}
\textbf{To be completed.}

\subsection{Previous Work using ASP}
\textbf{To be expanded.}

In 2013, Domenico Corapi et al.\ developed ASPAL\cite{aspal}, a system 
written in ASP for solving classical Inductive Logic Programming tasks, 
which brings to bear against these problems the efficiency of existing ASP 
solvers, and allows their optimisation features to be used to direct the 
search towards a desired optimal solution.

Building on this, in 2014, Mark Law et al.\ in 2014 developed 
ILASP\cite{ilasp}, implementing a form of ILP where an Answer Set Program 
representing the solution is learned inductively from positive and negative 
examples, with applications in agent planning.

\clearpage

\section{Language Definitions}
\subsection{While Language} \label{sec:whilan}

\subsubsection{Syntax}
\textbf{This is just copied from the Interim Report; I intend to make some 
changes to make it read better with the rest of the report.}

The following context-free grammar gives the (abstract) syntax of the While 
language. The basic elements of a program are (at the moment) integer 
constants and named variables. The exact set of possible constants and 
variables is specific to the program being generated, is given by the language 
bias.
\begin{align*}
   \trm{Const} \to\ & ... \mid -2 \mid -1 \mid 0 \mid 1 \mid 2 \mid ...
\\ \trm{Var}   \to\ & a \mid b \mid c \mid ... \mid x \mid y \mid z \mid ...
\end{align*}
A While program is a possible empty sequence of \emph{commands}, where a 
\emph{command} assigns a value to a variable, or takes the form of an \ttt{if} 
or \ttt{while} statement with a boolean guard and a further sequence of 
commands:
\begin{align*}
   \trm{Prog}  \to\ & \trm{Cmds}
\\ \trm{Cmds}  \to\ & \varepsilon \mid \trm{Cmd} \ttt{; } \trm{Cmds}
\\ \trm{Cmd}   \to\ & \trm{Var} \ \ttt{=} \ \trm{Expr}
\\            \mid\ & \ttt{if (} \trm{Bool} \ttt{) \char`\{\ } \trm{Cmds} \ttt{ \char`\}}
\\            \mid\ & \ttt{while (} \trm{Bool} \ttt{) \char`\{\ } \trm{Cmds} \ttt{ \char`\}}
\end{align*}
An arithmetic expression is a sum, difference, product, integer quotient, or 
integer remainder of two constants and/or variables. A boolean guard can test 
the relation less-than ($<$) or less-than-or-equal ($\leq$) on constants and 
variables. The structure of expressions is deliberately kept as simple as 
possible, to reduce the search space of programs:
\begin{align*}
   \trm{Expr}  \to\ & \trm{LExpr}\ (\ \ttt{+} \mid \ttt{-} \mid \ttt{*} \mid
                                      \ttt{/} \mid \ttt{\%} \ )\ \trm{LExpr}
\\ \trm{Bool}  \to\ & \trm{LExpr}\ (\ \ttt{<} \mid \ttt{<=}\ )\ \trm{LExpr}
\\ \trm{LExpr} \to\ & \trm{Const} \mid \trm{Var}
\end{align*}
Input and output is achieved by setting the initial values of certain 
\emph{input variables} before the program runs, and reading the values of 
certain \emph{output variables} after it has terminated.

Here is an example of a program satisfying this grammar, which takes an input 
integer $x$ and computes the output integer $z=\trm{Fib}(x)$, the $x$th 
Fibonacci number:
\begin{Verbatim}[samepage=true]
    z = 1;
    while (1 < x) {
        z = x + z;
        y = z - y;
        x = x - 1;
    };
\end{Verbatim}

A parse tree corresponding to this program (with intermediate non-terminals 
omitted when unambiguous) is given in Figure~\ref{fig:fibtree}.

\begin{figure}[h]
  \caption{The parse tree of a While program.}
  \label{fig:fibtree}
  \Tree[ .Prog [ .Cmds
    [ .\ttt{=} \ttt{x} \ttt{1} ]
    [ .Cmds
      [ .\ttt{while}
        [ .Bool [ .\ttt{<} \ttt{1} \ttt{x} ] ]
        [ .Cmds
          [ .\ttt{=} \ttt{z} [ .\ttt{+} \ttt{x} \ttt{z} ] ]
            [ .Cmds
              [ .\ttt{=} \ttt{y} [ .\ttt{-} \ttt{z} \ttt{y} ] ]
              [ .Cmds
                [ .\ttt{=} \ttt{x} [ .\ttt{-} \ttt{x} \ttt{1} ] ]
                $\varepsilon$
              ]
            ]
          ]
        ]
      $\varepsilon$
    ]
  ]]
\end{figure}

\subsubsection{Semantics}
\textbf{This is just copied from the Interim Report, but it's not 
currently correct; I intend to make several changes to reflect further 
work I've done on the interpreter.}

The semantics of a While program are the same as C programs with the same 
syntax, except:
\begin{enumerate}
    \item Execution starts at the first command of the program, and ends when 
    the last command has been executed. For simplicity, there is currently no 
    other way to halt execution, but we acknowledge that a \ttt{stop} command 
    may be needed for some programs, and may be added in future.
    \item All variables exist in the same global scope throughout the 
    execution of the program.
    \item Except for input variables, the initial value of every variable is 0.
    We change this in the future this so that variables may not be used unless 
    they are explicitly initialised.
    \item The results of arithmetical operations wrap around so that all 
    values remain within the range of possible integer constants. This is done 
    mainly to reduce the complexity of simulating programs using ASP. An 
    alternative would be to cause the program to fail when this happens, which 
    might be more desirable in eliminating spurious programs taking advantage 
    of integer overflow.
    \item Division by zero, and taking the remainder of division by zero,
    cause the program to formally not terminate.
\end{enumerate}

\subsection{Program Specification Language} \label{sec:spclng}
\textbf{To be completed.}

\clearpage 

\section{While Language Interpreter}
\textbf{This is just copied from the Interim Report. I intend to rewrite 
most of it so it that it fits into the below subsections and is coherent 
with the reset of the report.}

We have written in ASP an interpreter for the While language which, given 
facts specifying the initial values of input variables and the contents of 
each \emph{line} of the program, includes in the answer set facts saying 
(among other things) whether the program terminated, and if it did, what the 
final values of the output variables are.

The interpreter is capable of running at multiple traces of execution at once, 
each with possibly different input values, so the relevant facts about 
execution are also parameterised by a \emph{run identifier}. This 
functionality is essential to be able to learn programs that satisfy at once 
multiple test examples, as will be seen in section~\ref{sec:prgsyn}, Program 
Synthesiser.

The following facts specify a program which has an input variable $x$, and 
computes $z = \textrm{Fib}(x)$, the $x$th Fibonacci number, and also specifies 
6 different runs to perform:
\begin{Verbatim}[samepage=true]
    #const line_max=6.      % Maximum line number.
    var(x). var(y). var(z). % All variables used.
    
    line_instr(1, set(z, con(1))).               % z = 1;
    line_instr(2, while(lt(con(1), var(x)), 3)). % while (1 < x) {
    line_instr(3, set(z, add(var(y), var(z)))).  %    z = y + z;
    line_instr(4, set(y, sub(var(z), var(y)))).  %    y = z - y;
    line_instr(5, set(x, sub(var(x), con(1)))).  %    x = x - 1;
    line_instr(6, end_while).                    % }
    
    % Run the program with 6 different initial values of x:
    in(r1,x,1). in(r2,x,2). in(r3,x,3).
    in(r4,x,4). in(r5,x,5). in(r6,x,6).
\end{Verbatim}
The second parameter of the function symbol \texttt{while/2} gives the 
length of its body, i.e.\ the number of instructions it contains, 
excluding the \ttt{while} and \ttt{end\_while} lines.

When run with the While interpreter, this produces an answer set including the 
following facts:
\begin{Verbatim}[samepage=true]
    run_var_out(r1,x,1) run_var_out(r1,y,0) run_var_out(r1,z,1) 
    run_var_out(r2,x,1) run_var_out(r2,y,1) run_var_out(r2,z,1) 
    run_var_out(r3,x,1) run_var_out(r3,y,1) run_var_out(r3,z,2) 
    run_var_out(r4,x,1) run_var_out(r4,y,2) run_var_out(r4,z,3)
    run_var_out(r5,x,1) run_var_out(r5,y,3) run_var_out(r5,z,5)
    run_var_out(r6,x,1) run_var_out(r6,y,5) run_var_out(r6,z,8) 
\end{Verbatim}
The first column gives the final value of $x$ for each run and is not 
interesting, as this is just always 1 (or less), by the loop's guard. The 
second and third columns gives the final values of $y$ and $z$, and we can see 
that, as we hoped, $z=\textrm{Fib}(x_0)$ and $y=\textrm{Fib}(x_0-1)$, where 
$x_0$ is the initial value of $x$ for run $r_{x_0}$.

\subsection{Program Representation}
\textbf{To be completed.}

\subsection{Language Bias Representation}
\textbf{To be completed.}

\subsection{Implementation}
\textbf{To be completed.}

\clearpage

\section{Program Synthesis using Examples} \label{sec:synexm}
\textbf{This is just copied from the Interim Report. I intend to rewrite 
this section to give more operational details and it make it read better 
with the rest of the report.}

The example in the previous section shows how the program interpreter 
works, but it is not how the system is intended to be used. In actuality, 
the user specifies what the output values should be for various inputs, 
and the solver abducts a program satisfying those constraints.

This is achieved by including an aggregate defining the domain of 
admissable programs, and integrity constraints to enforce the test 
examples:
\begin{Verbatim}[samepage=true]
    % Exactly one instruction per line.
    1{ line_instr(L, I) : valid_line_instr(L, I) }1 :- line(L).
    
    valid_line_instr(L, set(V, E))      :- line(L), write_var(V), expr(E).
    valid_line_instr(L, if(B, 1..M))    :- line(L), bool(B), M=line_max-L.
    valid_line_instr(L, while(B, 1..M)) :- line(L), bool(B), M=line_max-L-1.
    valid_line_instr(L, end_while)      :- line(L).
    
    % All test examples must halt with the correct value.
    :- run_does_not_halt(R).
    :- run_var_out(R,X,Actual), out(R,X,Expected), Actual != Expected.
\end{Verbatim}
The predicate \ttt{out/3} is the counterpart to \ttt{in/3}, which was 
earlier used to specify the values of input variables, that asserts what 
the final value of a certain variable must be. The predicate 
\ttt{run\_does\_not\_halt/1} holds when a given run exceeds the time 
limit, or for some other reason does not formally terminate (e.g.\ when 
division by zero occurs). Further integrity constraints are included that 
ensure the generated program has a sensible structure, but for the sake of 
brevity are not shown here.

If we fix some facts in addition to the main program that includes the 
above machinery, we can immediately synthesise some simple programs:
\begin{Verbatim}[samepage=true]
    #const line_max=1.  % Number of lines.
    #const int_max=10.  % Maximum integer value.

    % Allowed explicit constants, variables, and writable variables:
    con(1). con(2). var(x). var(y). write_var(y).
    
    % Test examples:
    in(r0,x,0). out(r0,y,0).
    in(r1,x,1). out(r1,y,2).
    in(r2,x,2). out(r2,y,4).
    in(r3,x,3). out(r3,y,6).
\end{Verbatim}
The answer set of which includes:
\begin{Verbatim}[samepage=true]
    line_instr(1,set(y,add(var(x),var(x))))
\end{Verbatim}
Which is the program we expected, $y \gets x + x$.

As a slightly less trivial example, we can make the following 
specification of a program that computes $y = \sum_{i=0}^x i$, the $x$th 
triangular number:
\begin{Verbatim}[samepage=true]
    #const line_max=4.
    #const int_max=11. 
    con(1). var(x). var(y). write_var(x). write_var(y).
    
    in(r0,x,0). out(r0,y,0).
    in(r1,x,1). out(r1,y,1).
    in(r2,x,2). out(r2,y,3).
    in(r3,x,3). out(r3,y,6).
    in(r4,x,4). out(r4,y,10).
\end{Verbatim}
This program is solved in 12 seconds on a 3.4GHz machine, yielding:
\begin{Verbatim}[samepage=true]
    line_instr(1,while(le(con(1),var(x)),2)) % while (1 <= x) {
    line_instr(2,set(y,add(var(x),var(y))))  %    y = x + y
    line_instr(3,set(x,sub(var(x),con(1))))  %    x = x - 1
    line_instr(4,end_while)                  % }
\end{Verbatim}
Which is easily verified to generalise the examples in the intended way.

\clearpage

\section{Program Synthesis using Formulae} \label{sec:synfrm}
\subsection{Synthesis of Program Fragments}
\subsection{Synthesis of While Loop Bodies}

\section{Comparison with Existing Systems}

\section{Evaluation}
\subsection{Power and Accuracy}
\subsubsection{Extent of Capabilities}
\subsubsection{Correctness of Generated Programs}
\subsection{Efficiency}
\subsubsection{Time and Space Usage}
\subsubsection{Number of Examples Needed}
\subsubsection{Quality of Generated Programs}

\section{Conclusions and Future Work}
\subsection{Conclusion}
\subsection{Possible Extensions}
\subsection{Plans for Future Work}

\clearpage
\begin{thebibliography}{9}
    \bibitem{muggleton94}
        Muggleton S, De Raedt L (1994).
        \emph{Inductive Logic Programming: Theory and methods}.
        The Journal of Logic Programming, vol. 19-20, page 629-679.
    \bibitem{potassco}
        Potassco, the Potsdam Answer Set Solving Collection. 
        \url{http://potassco.sourceforge.net}
    \bibitem{glimpse}
        Anger C, Konczak K, Linke T, Schaub T (2005).
        \emph{A Glimpse of Answer Set Programming}. 
        \url{http://www.cs.uni-potsdam.de/wv/pdfformat/ankolisc05.pdf}
    \bibitem{popl10syn}
        Srivastava S, Gulwani S, Foster J S (2010).
        \emph{From Program Verification to Program Synthesis}.
        \url{http://www.cs.umd.edu/~saurabhs/pubs/popl10-syn.html}
    \bibitem{tds}
        Perelman D, Gulwani S, Grossman D, Provost P (2014).
        \emph{Test-Driven Synthesis}.
        \url{http://research.microsoft.com/en-us/um/people/sumitg/pubs/pldi14-tds.pdf}
    \bibitem{aspal}
        Corapi D, Russo A, Lupu E (2011)
        \emph{Inductive Logic Programming in Answer Set Programming}. 
        \url{http://ilp11.doc.ic.ac.uk/short_papers/ilp2011_submission_20.pdf}
    \bibitem{ilasp}
        Law M, Russo A, Broda K (2014).
        \emph{Inductive learning of answer set programs}.
        \url{https://www.doc.ic.ac.uk/~ml1909/ILASP_Paper.pdf}
\end{thebibliography}

\end{document}
