\documentclass[a4paper,twoside,notitlepage]{report}

\usepackage{parskip}
\usepackage{hyperref}
\usepackage[nottoc,numbib]{tocbibind}
\usepackage[fleqn]{amsmath}
\usepackage{qtree}
\usepackage{float}
\usepackage{fancyvrb}
\usepackage{comment}
\usepackage{tabularx}
\usepackage[color,leftbars]{changebar}
\usepackage{color}
\usepackage{listings}

\floatstyle{boxed}
\restylefloat{figure}
\newcommand{\ttt}{\texttt}
\newcommand{\trm}{\textrm}
\setcounter{tocdepth}{1}
\cbcolor{red}

\begin{document}

\title{Synthesis of Simple While Programs Using Answer Set Programming}
\author{Joseph Crowe \\ Supervised by Krysia Broda and Mark Law}
\date{18th June 2015}
\maketitle

\begin{abstract}
sdfsf
\end{abstract}
\clearpage

\section*{Acknowledgements}
I owe many thanks to my supervisors Dr.\ Krysia Broda and Mark Law for their 
advice, support, tolerance, and many valuable suggestions over the course of 
the project.

Thanks also to Dr.\ Alessandra Russo for some insightful feedback and 
suggestions given during the interim project review.
\clearpage

\tableofcontents

\chapter{Introduction} \label{chp:intro}

One of the aims of computer science is to make it easier for people to 
generate \emph{computer programs}, which are the machine-readable 
representations of desired behaviour executed by a computer in order to 
perform some useful computation.

In many cases the user might not have a clear idea of how a calculation is 
to be performed, but will be able to point out some concrete examples of 
its expected behaviour: the user intuitively knows that for certain 
inputs, they expect the program to behave in a certain way. This is a 
problem faced by students of Computing, for example, which if addressed 
could be beneficial to their education.

While certainly not the most reliable way of specifying a computer 
program, it might be the best approximation that a user can produce with 
limited knowledge of the problem domain; and if the examples are 
sufficiently comprehensive, it has been seen that it is often enough to 
make a good guess at what program the user has in mind.

This project concerns the generation of \emph{imperative} computer 
programs, consisting of sequences of instructions to be executed in order, 
which are relatively easy to compile into a form that can be executed on 
most computing devices without further processing.

In particular, we restrict our attention to a \emph{simple while language} 
containing the minimal features for computation involving whole numbers: 
branching, using \emph{if statements}; looping, using \emph{while loops}, 
and some basic arithmetic operators such as addition and multiplication.
See Chapter~\ref{chp:whilan} for a formal description of this language.

An example of such a program is the following, which takes as input an initial 
value of \texttt{x}, say $x_0 \ge 0$, and leaves \texttt{y} equal to the 
$x_0$th power of 2, $y = 2^{x_0}$:
\begin{Verbatim}[samepage=true]
    y = 1;
    while (x > 0) {
       y = y * 2;
       x = x - 1;
    }
\end{Verbatim}

We now have a way to instruct a computer to calculate the powers of two, 
but is it necessary for a person to write out the program in full? It 
might be easy in this case, but for more complicated programs this can be 
time-consuming, error prone, and dependent on specialised knowledge.

Lacking the inclination to write a program in the above form, we might 
wish instead to specify its behaviour as mathematical relation between 
its input and output variables, such as $y = 2^{x_0}$; or perhaps we do not 
even have a mathematical expression in mind, but simply wish to provide a 
list of examples of what the program should do:
\begin{center}
\begin{tabular}{| l || r | r | r | r | r | r |}
    \hline
    $x$ & 0 & 1 & 2 & 3 & 4  &  5 \\
    \hline
    $y$ & 1 & 2 & 4 & 8 & 16 & 32 \\
    \hline
\end{tabular}
\end{center}

The objective of this project is to provide automatic programming tools 
that address this problem by allowing a program to be generated from a 
list of input/output examples it is desired to satisfy, or from a 
mathematical or logical relation which is desired to hold over the whole 
domain of input/output values.

There is a significant body of previous work in the automatic synthesis of 
programs (see Chapter~\ref{chp:bkgsyn}). Most can be classified as 
\emph{inductive}, which take a machine-learning approach to generalising a set 
of input/output examples with a program in a particular language; or 
\emph{deductive}\cite{cheatham86}\cite{bundy90}\cite{colon05}, which seek to 
construct a program which provably satisfies a high-level representation of 
desired behaviour.

There have been recent successes in inductive program synthesis\cite{tds}, 
which have inspired this project to take an inductive approach to generating 
imperative programs; however, the problem in its full generality is far from 
solved, and with the application of new tools and techniques, we hope to break 
new ground and document their effectiveness.

In particular, we use a type of logic programming called Answer Set 
Programming (see Chapter~\ref{chp:bkgasp}), which was previously used for 
inductive synthesis of logic programs, as the main part of a system 
capable of inductively synthesising imperative programs. For running 
Answer Set Programs we use \emph{Clingo 3} from the Potsdam Answer Set 
Solving Collection (Potassco)\cite{potassco}.

\section{Contributions}
\begin{itemize}
    \item We present a tool which, given a list of input/output examples 
    over a given variable domain will generate a program satisfying the
    examples, if one exists given the certain constraints. See 
    Chapter~\ref{chp:synexm}.

    \item We allow the structure of the generated program to be partially 
    defined by the user, and show that this results in a significant increase
    in speed of generation. See Chapter~\ref{chp:synexm}.

    \item We extend this system with the ability to judiciously generate 
    examples from a functional specification written in propositional
    logic, instead of relying on a list of examples from the user. See
    Chapter~\ref{chp:genexm}.

    \item Particularising the above to the generation of programs 
    involving loops, we allow a \emph{loop invariant} and \emph{variant}
    to be specified by the user, and use this to generate the loop body
    separately from the rest of the program, also resulting in an 
    increase in speed of generation. See Chapter~\ref{chp:gensub}.
\end{itemize}

\chapter{Background: Automatic Program Synthesis} \label{chp:bkgsyn}

The notion of automatic programming, in the sense of 
allowing a computer to take part in the writing of a computer program, has its 
roots in the design of optimising compilers to translate a high-level program 
into an efficient low-level program while preserving behaviour. The 
\emph{Fortran I} compiler\cite{fortran} is a well known early example of this. 
Since then, researchers have attempted to bridge increasingly wider gaps 
between specification language and output language. More detailed surveys of 
the subject can be found at e.g.\ 
\cite{goldberg86}\cite{deville94}\cite{basin04}.

\section{Deductive Program Synthesis}

In the \emph{deductive} variety of program synthesis, in which the task is to 
derive a correct program from a formal specification, there are several 
documented approaches. The oldest is \emph{transformational synthesis}, which 
seeks to transform the specification into a correct program through multiple 
correctness-preserving changes. See \cite{cheatham86} for an example.

Also used in deductive synthesis is the methodology of \emph{schema-guided 
synthesis}, in which templates for program fragments in the target language, 
called \emph{schemas}, are used to build a larger program. This reduces the 
complexity of the task, as the work of constructing and proving the 
correctness of the schema has already been done. For example, a theoretical 
system is developed at \cite{flener97}, and a more recent application to 
numerical computation is given at \cite{colon05}.

Finally, the \emph{constructive} approach to deductive program synthesis uses 
the fact that the specification can be written as a formula whose 
satisfiability asserts the existence of a program with the specified 
behaviour; and a proof of the formula's satisfiability is equivalent to the 
construction of a such a program. Constructive program synthesis therefore 
borrows the power of theorem-proving techniques to perform the difficult part 
of program synthesis. An example of this applied to the synthesis of logic 
programs is given at \cite{bundy90}.

More recent advances in deductive program synthesis use combinations of the 
above techniques. For example, in \cite{popl10syn}, it is shown that given a 
functional specification of an imperative program, relating its inputs and 
outputs with logical formulae, and given also the looping structure of the the 
program, it is possible to infer a program satisfying these constraints, using 
techniques previously used for program verification.

\section{Inductive Program Synthesis}

On the other hand, in \emph{inductive} program synthesis, the task is to 
produce a hypothetical program, given an incomplete specification of its 
behaviour, which usually takes the form of a list of input/output examples. 
This can be viewed as a form of machine learning, where the synthesised 
program is a hypothesis generalising the given examples.

David Perelman, Sumit Gulwani, et al.\ in 2014 developed a system\cite{tds} 
based on the principle of ``programming by example,'' which generates and 
iteratively refines a program from a sequence of increasingly more general 
sets of input/output examples. Notably, their system is not limited to 
imperative programs, but allows arbitrary domain-specific languages to be 
defined and used with the system.

\chapter{Background: Answer Set Programming} \label{chp:bkgasp}

Answer Set Programming (ASP) is a form of logic programming particularly
suited to search problems over large domains (such as the domain of all
imperative programs of a given length). An Answer Set Program distinguishes
the result to be computed by a set of propositional facts and rules in the
domain. Importantly, ASP includes \emph{aggregates}, \emph{integrity
constraints}, and \emph{negation as failure}, where a rule can be conditional
on the inability of prove that some proposition is true, which allows
\emph{non-monotonic reasoning}. The result of running an ASP is an
\emph{answer set} of facts which is consistent with the program, forms a
\emph{stable model}, and is minimal in a certain sense. For further details,
see \cite{glimpse}, which gives a concise introduction to the paradigm.

\section{Previous Work using ASP}

In 2013, Domenico Corapi et al.\ developed ASPAL\cite{aspal}, a system written
in ASP for solving classical Inductive Logic Programming tasks, which brings
to bear against these problems the efficiency of existing ASP solvers, and
allows their optimisation features to be used to direct the search towards a
desired optimal solution.

Building on this, in 2014, Mark Law et al.\ in 2014 developed
ILASP\cite{ilasp}, implementing a form of ILP where an Answer Set Program
representing the solution is learned inductively from positive and negative
examples, with applications in agent planning.

\chapter{Programs in the While Language} \label{chp:whilan}

\section{Syntax and Semantics}

The output language of our system is an imperative programming language that 
can be described as a ``simple while language''. A running program's state is 
kept in a fixed number of global integer variables, and the execution path is 
controlled by \emph{if} and \emph{while} statements. This language is 
therefore Turing complete, its expressive power in principle no less than any 
other programming language.

\subsection{Syntax}
The following context-free grammar gives the (abstract) syntax of the While 
language. The basic elements of a program are integer constants and named 
variables. The exact set of possible constants and variables is specific to 
the program being generated, is given by the language bias (see 
Section~\ref{sec:spclng}).
\begin{align*}
   \trm{Const} \to\ & ... \mid -2 \mid -1 \mid 0 \mid 1 \mid 2 \mid ...
\\ \trm{Var}   \to\ & a \mid b \mid c \mid ... \mid x \mid y \mid z \mid ...
\end{align*}
A While program is a possibly empty sequence of \emph{commands}, where a 
\emph{command} assigns a value to a variable, or takes the form of an \ttt{if} 
or \ttt{while} statement with a boolean guard and a further sequence of 
commands:
\begin{align*}
   \trm{Prog}  \to\ & \trm{Cmds}
\\ \trm{Cmds}  \to\ & \varepsilon \mid \trm{Cmd} \ttt{; } \trm{Cmds}
\\ \trm{Cmd}   \to\ & \trm{Var} \ \ttt{=} \ \trm{Expr}
\\            \mid\ & \ttt{if (} \trm{Bool} \ttt{) \char`\{\ } \trm{Cmds} \ttt{ \char`\}}
\\            \mid\ & \ttt{while (} \trm{Bool} \ttt{) \char`\{\ } \trm{Cmds} \ttt{ \char`\}}
\end{align*}
An arithmetic expression is a sum, difference, product, integer quotient, or 
integer remainder of two constants and/or variables. A boolean guard can test 
the relation less-than ($<$) or less-than-or-equal ($\leq$) on constants and 
variables. The structure of expressions is deliberately kept as simple as 
possible, to reduce the search space of programs:
\begin{align*}
   \trm{Expr}  \to\ & \trm{LExpr}\ (\ \ttt{+} \mid \ttt{-} \mid \ttt{*} \mid
                                      \ttt{/} \mid \ttt{\%} \ )\ \trm{LExpr}
\\ \trm{Bool}  \to\ & \trm{LExpr}\ (\ \ttt{<} \mid \ttt{<=}\ )\ \trm{LExpr}
\\ \trm{LExpr} \to\ & \trm{Const} \mid \trm{Var}
\end{align*}
Input and output is achieved by setting the initial values of certain 
\emph{input variables} before the program runs, and reading the values of 
certain \emph{output variables} after it has terminated.

\subsection{Example Program}

Recall the example program from Chapter~\ref{chp:intro}:
\begin{Verbatim}[samepage=true]
    y = 1;
    while (x > 0) {
       y = y * 2;
       x = x - 1;
    }
\end{Verbatim}

A parse tree corresponding to this program (with intermediate non-terminals 
omitted when unambiguous) is given in Figure~\ref{fig:parsetree}.

\begin{figure}[h]
  \caption{The parse tree of a While program.}
  \label{fig:parsetree}
  \Tree[ .Prog [ .Cmds
    [ .\ttt{=} \ttt{y} \ttt{1} ]
    [ .Cmds
      [ .\ttt{while}
        [ .Bool [ .\ttt{>} \ttt{x} \ttt{0} ] ]
        [ .Cmds
          [ .\ttt{=} \ttt{y} [ .\ttt{*} \ttt{y} \ttt{2} ] ]
          [ .Cmds
            [ .\ttt{=} \ttt{x} [ .\ttt{-} \ttt{x} \ttt{1} ] ]
            $\varepsilon$
          ]
        ]
      ]
      $\varepsilon$
    ]
  ]]
\end{figure}

\subsection{Semantics}
The semantics of While programs are the same as C programs with the same 
syntax, except:
\begin{enumerate}
    \item Execution starts at the first command of the program, and ends when 
    the last command has been executed. For simplicity, there is currently no 
    other way to halt execution, but we acknowledge that a \ttt{stop} command 
    may be needed for some programs, and may be added in the future.
    \item All variables exist in the same global scope throughout the 
    execution of the program.
    \item If a time limit is defined in the language bias (in the current 
    system, one must be defined) and the number of instructions executed by 
    the program exceeds that limit, the program will be considered to have 
    failed to terminate, and such programs will not be considered as 
solutions.
    \item A program attempting to perform arithmetic using a variable to which
    no value has been assigned will formally fail to terminate, therefore 
    excluding such programs from being generated.
    \item Arithmetic results exceeding the range of integers allowed by the 
    language bias cause the program to formally fail to terminate.
    \item Division by zero, and taking the remainder of division by zero,
    cause the program to formally fail to terminate.
\end{enumerate}

\section{Program Encoding in ASP} \label{sec:progenc}

In choosing an encoding of While programs as ASP facts, it is necessary to 
consider that we eventually want to search regions in the space of all 
possible programs, and that the program representation in ASP can have a 
significant effect on the efficiency of this search.

Acknowledging the fact that Answer Set Programs need to be fully grounded 
before evaluation, and to reduce the size of this grounding, it was chosen 
to use a ``flat'' representation of programs as a fixed-length sequence of 
discrete instructions. This is in contrast with the hierarchical 
representation of abstract syntax trees (ASTs) used elsewhere to reason 
about While programs, which due to their dynamic shape generated a large 
number of possible ground facts.

The chosen ``flat'' representation comes with the drawback that it it 
possible to represent nonsensical programs that don't correspond to any 
AST, but these configurations can be eliminated without excessive cost by 
the introduction of integrity constraints to enforce a hierarchical 
structure. See Chapter~\ref{chp:synexm} for more details of how this is 
implemented.

Programs are represented as sequences of numbered \emph{lines}, where each 
line contains an \emph{instruction}. The fact that the instruction 
\verb|Instr| occurs on line \verb|L|, where \verb|L| ranges from 1 to some 
maximum line number, is represented by:
\begin{Verbatim}[samepage=true]
    line_instr(L, Instr).
\end{Verbatim}

The instruction \verb|Instr| may be any of the following terms:

\begin{tabularx}{\textwidth}{lX}
    \verb|   set(Var, Expr)|
&   The value of expression \verb|Expr| is assigned to variable \verb|Var|.
\\
\\  \verb|   if(Bool, Length)|
&   If the boolean guard \verb|Bool| evaluates as true, the next \verb|Length|
    instructions are executed; otherwise, they are skipped.
\\
\\  \verb|   while(Bool, Length)|
&   The next \verb|Length| instructions are executed as many times as the 
    guard \verb|Bool| remains true.
\\
\\  \verb|   end_while|
&   This special instruction marks the end of \verb|while| loop, and must 
    be present immediately after the instructions encompassed by each loop.
\end{tabularx}

This representation bears a passing resemblance to the discrete, low-level 
instructions used in assembly languages (or machine bytecode), except that 
each instruction represents a higher-level program element, and so a greater 
amount structure can be enforced on their arrangement.

As the reader may have noted, the \verb|end_while| is not strictly necessary, 
as its position could be inferred from the corresponding \verb|while| 
instruction's \verb|Length|; but it is included to simplify the implementation 
of a virtual machine for running these programs: when encountering an 
\verb|end_while|, execution returns to the corresponding \verb|while| to 
possibly repeat the loop, which is a discrete operation in itself. This is not 
necessary for \verb|if| statements, so there is no \verb|end_if| instruction.

Expressions \verb|Expr|, which may occur on the right-hand side of 
\verb|set| instructions and inside boolean guards, take the following 
forms, where \verb|Expr1| and \verb|Expr2| are also expressions:

\begin{tabular}{lll}
    \verb|   var(Var)|          & The value of a variable \verb|Var|
\\  \verb|   con(Con)|          & The constant value \verb|Con|
\\  \verb|   add(Expr1, Expr2)| & The sum \verb|Expr1 + Expr2|
\\  \verb|   sub(Expr1, Expr2)| & The difference \verb|Expr1 - Expr2|
\\  \verb|   mul(Expr1, Expr2)| & The product \verb|Expr1 * Expr2|
\\  \verb|   div(Expr1, Expr2)| & The quotient \verb|Expr1 / Expr2|
\\  \verb|   mod(Expr1, Expr2)| & The remainder \verb|Expr1 % Expr2|
\end{tabular}

Boolean guards \verb|Bool|, which control the execution of \verb|if| and 
\verb|while| instructions, take the following forms, where \verb|Expr1| 
and \verb|Expr2| are expressions:

\begin{tabular}{lll}
    \verb|   lt(Expr1, Expr2)| & less than:          & \verb|Expr1 <  Expr2|
\\  \verb|   le(Expr1, Expr2)| & less than or equal: & \verb|Expr1 <= Expr2|
\end{tabular}

Below is an example of the program from Chapter~\ref{chp:intro}, which 
computes powers of two, represented in this encoding, with comments on 
the right giving each represented instruction in its more familiar form:
\begin{Verbatim}[samepage=true]
    line_instr(1, set(y, con(1))).                % y = 1;
    line_instr(2, while(lt(con(0), var(x)), 2)).  % while (0 < x) {
    line_instr(3, set(y, mul(var(y), con(2)))).   %     y = y * 2;
    line_instr(4, set(x, sub(var(x), con(1)))).   %     x = x - 1;
    line_instr(5, end_while).                     % }
\end{Verbatim}

\section{Running Programs in ASP} \label{sec:runasp}

We have implemented in ASP an interpreter for the While language, 
\verb|run.lp|, which when combined with a set of facts giving a program 
such as the above, and further facts specifying the initial values of 
variables, computes an answer set containing facts giving the final values 
of variables after running the program. The constants \verb|time_max|, 
\verb|int_min| and \verb|int_max| must also be specified by the user, to 
effect suitable execution limits and to allow the program's grounding to 
be finite.

\verb|run.lp| allows multiple execution traces to be computed at once, 
using the predicate \verb|in/3|, which takes the following form:
\begin{Verbatim}[samepage=true]
    in(RunID, Variable, InitialValue).
\end{Verbatim}
For each execution trace a unique \verb|RunID| is assigned, and one or 
more instances of \verb|in/3| are defined, one for each input variable.

The answer set contains facts of the following form:
\begin{Verbatim}[samepage=true]
    run_var_out(RunID, Variable, FinalValue)
    run_var_out(RunID, Variable, unset)
    run_does_not_halt(RunID)
\end{Verbatim}

The first signifies that \verb|RunID| terminated successfully with the 
given final value for a variable; the second signifies that the run 
terminated successfully, but without assigning a value for a variable; and 
the last signifies that the run did not successfully terminate, which 
could be because the number of instructions executed exceeded 
\verb|time_max| (which would happen if the program contained an infinite 
loop, for example), or because the value of a variable exceeded the range 
defined by \verb|int_min| and \verb|int_max|, or because of another 
illegal operation such as division by zero.

\subsubsection{Implementation}

In order to achieve this, \verb|run.lp| computes for 
every run \verb|R|, for every time \verb|T| with $0 \leq \verb|T| < 
\verb|time_max|$, the line \verb|L| of the program currently being 
executed, and the value of every variable. A particular run is considered 
to have terminated successfully if an \verb|L| is reached for which there 
is no \verb|line_instr|, i.e. the end of the program has been reached.

Also needed are the values of arithmetic expressions \verb|E| and boolean 
expressions \verb|B| for certain runs \verb|R| and at certain times 
\verb|T|. The fact \verb|run_expr(R, T, E, C)| means that the expression 
represented by the atom \verb|E| evaluates to the integer \verb|C|. The 
fact \verb|run_bool(R, T, B)| means that the boolean expression \verb|B| 
evaluates as true, and the absence of this fact means that it evaluates as 
false. The rules implementing these predicates are lengthy but 
straightforward, and so their implementation is omitted from this chapter 
for brevity.

Also defined are the domain predicates \verb|run/1|, \verb|int/1| and 
\verb|var/1| listing the run IDs, the legal integer values and the 
existing variables, which are derived straightforwardly from the 
aforementioned constants and from \verb|line_instr/2|.

The line number \verb|L| for run \verb|R| at time \verb|T| is represented 
by \verb|run_line(R, T, L)|, and computed using the following rules:
\begin{Verbatim}
    % Identify lines where execution may jump to a remote point.
    line_jump(L) :- line_instr(L, if(_,_)).
    line_jump(L) :- line_instr(L, while(_,_)).
    line_jump(L) :- line_instr(L, end_while).
    
    % For efficiency, project out if/while parameters.
    line_instr_if_guard(L, G)     :- line_instr(L, if(G, _)).
    line_instr_if_length(L, B)    :- line_instr(L, if(_, B)).
    line_instr_while_guard(L, G)  :- line_instr(L, while(G, _)).
    line_instr_while_length(L, B) :- line_instr(L, while(_, B)).
    
    % Start at line 1, and by default move to the next line at each step.
    run_line(R,0,1) :-
        run(R).
    run_line(R,T+1,L+1) :-
        line(L), run(R,T), run_line(R,T,L),
        not line_jump(L), not run_fail(R,T).
    
    % Run if statements.
    run_line(R,T+1,L+1) :-
        run(R,T), run_line(R,T,L), line_instr_if_guard(L,B),
        run_bool(R,T,B).
    run_line(R,T+1,L+BodyLength+1) :-
        run(R,T), run_line(R,T,L), line_instr(L,if(B,BodyLength)),
        not run_bool(R,T,B).
    
    % Run while loops.
    run_line(R,T+1,L+1) :-
        % Boolean guard is true upon (re-)entering loop.
        run(R,T), run_line(R,T,L), line_instr_while_guard(L,B),
        run_bool(R,T,B).
    run_line(R,T+1,L+BodyLength+2) :-
        % Boolean guard is false upon (re-)entering loop.
        run(R,T), run_line(R,T,L), line_instr(L,while(B,BodyLength)),
        not run_bool(R,T,B).
    run_line(R,T+1,HeadLine) :-
        % Re-enter loop after reaching end_while.
        run(R,T), run_line(R,T,L), line_instr(L,end_while),
        line_instr_while_length(HeadLine, BodyLength),
        L == HeadLine+BodyLength+1.
\end{Verbatim}

The value \verb|C| of the variable \verb|X| in run \verb|R| at time 
\verb|T| is represented by \verb|run_var(R, T, X, C)|, and is implemented 
by the following rules:
\begin{Verbatim}
    % Initialise variables to their input value, if any.
    run_var(R,0,X,C) :- in(R,X,C), int(C).
    
    % Identify lines where a particular variable's value may change.
    line_set(L,X) :- line_instr(L, set(X,_)).
    
    % On a set statement, update variables; otherwise, leave them constant.
    run_var(R,T+1,X,C) :-
        run_line(R,T,L), not line_set(L,X),
        run_var(R,T,X,C), int(C).
    run_var(R,T+1,X,C) :-
        run_line(R,T,L), line_set(L,X), line_instr(L,set(X,E)),
        run_expr(R,T,E,C), int(C).
    
    % Identify expressions which evaluate to a legal result.
    run_expr_not_fail(R,T,E) :- run_expr(R,T,E,_).
    
    % Identify the time at which a run fails due to illegal arithmetic.
    run_fail(R,T) :-
        run_line(R,T,L), line_set(L,X), line_instr(L,set(X,E)),
        not run_expr_not_fail(R,T,E).
\end{Verbatim}

Finally, in order to make use of the computed results and to define 
\verb|run_var_out| and \verb|run_does_not_halt| mentioned above, some 
further computation is needed, and is implemented by the following rules:

\begin{Verbatim}[samepage=true]
    % run(R,T) if test case R runs to at least time T.
    run(R,T) :- run_line(R,T,L), T<time_max, line(L).
    
    % run_halt(R,T) if test case R halts normally at time T.
    run_halt(R,T) :- run_line(R,T,L), T<time_max, not line(L).
    
    run_does_halt(R) :- run_halt(R,_).
    run_does_not_halt(R) :- run(R), not run_does_halt(R).
    
    % run_var_out(R,X,C) if the final value of X in run R is C.
    run_var_out(R,X,C)     :- run_var(R,T,X,C), not run(R,T).
    run_var_out(R,X,unset) :- run(R), var(X), not run_var_out_set(R,X).
    run_var_out_set(R,X)   :- run_var_out(R,X,C), C != unset.
\end{Verbatim}

\subsection{Example Programs}

We now introduce some examples of programs that can be run using 
\verb|run.lp| and their sample inputs and outputs. We will return to some 
of these same programs in later chapters to show how they can be 
automatically generated.

\subsubsection{Powers of Two}
When we run \verb|run.lp| with the constants \verb|time_max=99|, 
\verb|int_min=0|, \verb|int_max=32|, with the facts from the example at 
the end of Section~\ref{sec:progenc}, and with the following additional 
facts:
\begin{Verbatim}[samepage=true]
    in(run0,x,0).
    in(run1,x,1).
    in(run2,x,2).
    in(run3,x,3).
    in(run4,x,4).
    in(run5,x,5).
\end{Verbatim}
Then the resulting answer set computed by Clingo 3 contains the following 
instances of \verb|run_var_out/3|:
\begin{Verbatim}[samepage=true]
    run_var_out(run0,x,0)  run_var_out(run0,y,1)
    run_var_out(run1,x,0)  run_var_out(run1,y,2)
    run_var_out(run2,x,0)  run_var_out(run2,y,4)
    run_var_out(run3,x,0)  run_var_out(run3,y,8)
    run_var_out(run4,x,0)  run_var_out(run4,y,16) 
    run_var_out(run5,x,0)  run_var_out(run5,y,32)
\end{Verbatim}
Which as we would expect gives the correct result, with $y = 2^{x_0}$, 
where $y$ is the final value of \verb|y| and $x_0$ is the initial value of 
\verb|x|.

\subsubsection{Triangular Numbers}
The $n$th triangular number is defined as $T_n=\sum_{i=0}^n i$. There is 
also a closed formula, $T_n=\tfrac{n(n+1)}2$. Therefore, the following two 
programs are functionally equivalent:
\begin{Verbatim}[samepage=true]
    line_instr(1, set(t, add(var(n), con(1)))).   % t = n + 1;
    line_instr(2, set(t, mul(var(t), var(n)))).   % t = t * n;
    line_instr(3, set(t, div(var(t), con(2)))).   % t = t / 2;
\end{Verbatim}
\begin{Verbatim}[samepage=true]
    line_instr(1, set(t, con(0))).                % t = 0;
    line_instr(2, while(lt(con(0), var(n)), 2)).  % while (n > 0) {
    line_instr(3, set(t, add(var(t), var(n)))).   %     t = t + n;
    line_instr(4, set(n, sub(var(n), con(1)))).   %     n = n - 1;
    line_instr(5, end_while).                     % }
\end{Verbatim}

Both of the above programs can be run with the following parameters:
\begin{Verbatim}[samepage=true]
    #const time_max=50.
    #const int_min=0.
    #const int_max=50.
    
    in(run0,n,0).
    in(run1,n,1).
    in(run2,n,2).
    in(run3,n,3).
    in(run4,n,4).
    in(run5,n,5).
\end{Verbatim}

To produce the following output, the familiar sequence of triangular 
numbers whose sequence of differences between successive terms is the 
natural numbers:
\begin{Verbatim}[samepage=true]
    run_var_out(run0,t,0)
    run_var_out(run1,t,1)
    run_var_out(run2,t,3)
    run_var_out(run3,t,6)
    run_var_out(run4,t,10)
    run_var_out(run5,t,15)
\end{Verbatim}

\subsubsection{Fibonacci Sequence}
The Fibonacci Sequence $(F_n)_{n=1}^\infty$, given by $F_1=F_2=1$, 
$F_{n+2}=F_{n}+F_{n+1}$, can be computed by the following program, which 
takes as input \verb|n|, and produces $\verb|f|=F_{\verb|n|}$, the 
\verb|n|th term in the sequence:
\begin{Verbatim}[samepage=true]
    line_instr(1, set(e, con(0))).                % e = 0;
    line_instr(1, set(f, con(1))).                % f = 1;
    line_instr(2, while(lt(con(1), var(n)), 3)).  % while (n > 1) {
    line_instr(3, set(f, add(var(e), var(f)))).   %    f = e + f;
    line_instr(4, set(e, sub(var(f), var(e)))).   %    e = f - e;
    line_instr(5, set(n, sub(var(n), con(1)))).   %    n = n - 1;
    line_instr(6, end_while).                     % }
\end{Verbatim}

We can run this to compute the first 6 terms of the sequence using the 
following parameters:
\begin{Verbatim}[samepage=true]
    #const time_max=30.
    #const int_min=0.
    #const int_max=10.
    
    in(run1,n,1).
    in(run2,n,2).
    in(run3,n,3).
    in(run4,n,4).
    in(run5,n,5).
    in(run6,n,6).
\end{Verbatim}

Which results in an answer set containing the following results:
\begin{Verbatim}[samepage=true]
    run_var_out(run1,n,1) run_var_out(run1,e,0) run_var_out(run1,f,1)
    run_var_out(run2,n,1) run_var_out(run2,e,1) run_var_out(run2,f,1) 
    run_var_out(run3,n,1) run_var_out(run3,e,1) run_var_out(run3,f,2)
    run_var_out(run4,n,1) run_var_out(run4,e,2) run_var_out(run4,f,3)
    run_var_out(run5,n,1) run_var_out(run5,e,3) run_var_out(run5,f,5)
    run_var_out(run6,n,1) run_var_out(run6,e,5) run_var_out(run6,f,8)
\end{Verbatim}
In the third column, we can see the final values of \verb|f|, which indeed 
form the familiar Fibonacci sequence. The second column, with the values 
of \verb|e|, forms the same sequence but shifted forward by one space, 
which offers an insight into how the program works.

\subsubsection{Median of Three Numbers}

Given three real numbers $a$, $b$ and $c$, their median is the unique real 
number $m\in\{a,b,c\}$ such that $\min(a,b,c)\leq m\leq\max(a,b,c)$. An 
example of a program that finds the median of three integers is the 
following, which puts \verb|a|, \verb|b| and \verb|c| in ascending order 
using \verb|m| as a swap variable, then sets \verb|m| to \verb|b|, the 
middle value:
\begin{Verbatim}[samepage=true]
    line_instr( 1, if(lt(var(c), var(a)), 3)).  % if (a > c) {
    line_instr( 2, set(m, var(a))).             %     m = a;
    line_instr( 3, set(a, var(c))).             %     a = c;
    line_instr( 4, set(c, var(m))).             %     c = m; }
    line_instr( 5, if(lt(var(b), var(a)), 3)).  % if (a > b) {
    line_instr( 6, set(m, var(a))).             %     m = a;
    line_instr( 7, set(a, var(b))).             %     a = b;
    line_instr( 8, set(b, var(m))).             %     b = m; }
    line_instr( 9, if(lt(var(c), var(b)), 3)).  % if (b > c) {
    line_instr(10, set(m, var(b))).             %     m = b;
    line_instr(11, set(b, var(c))).             %     b = c;
    line_instr(12, set(c, var(m))).             %     c = m; }
    line_instr(13, set(m, var(b))).             % m = b;
\end{Verbatim}

Configured with the following parameters:
\begin{Verbatim}[samepage=true]
    #const time_max=10.
    #const int_min=0.
    #const int_max=10.

    in(r123,a,11). in(r123,b,12). in(r123,c,13).
    in(r132,a,21). in(r132,b,23). in(r132,c,22).
    in(r312,a,33). in(r312,b,31). in(r312,c,32).
    in(r321,a,43). in(r321,b,42). in(r321,c,41).
    in(r231,a,52). in(r231,b,53). in(r231,c,51).
    in(r213,a,62). in(r213,b,61). in(r213,c,63).
\end{Verbatim}

Produces the following output:
\begin{Verbatim}[samepage=true]
    run_var_out(r123,m,12)
    run_var_out(r132,m,22)
    run_var_out(r312,m,32)
    run_var_out(r321,m,42)
    run_var_out(r231,m,52)
    run_var_out(r213,m,62)
\end{Verbatim}

\subsubsection{$n$th Prime Number}

A positive integer $p$ is prime if $p>1$ and $p$ has no proper divisors, 
i.e. there are no two integers $k,j$ such that $1<k<p$ and $p=kj$. 
Euclid's Theorem, a result in elementary number theory, states that there 
are infinitely many prime numbers; so we can define a sequence 
$(p_n)_{n=1}^\infty=(2, 3, 5, 7, ...)$, where $p_n$ is the $n$th prime 
number. There are known a number of efficient algorithms to compute $p_n$ 
given $n$, but the following program implements a relatively simple one:
\begin{Verbatim}[samepage=true]
    line_instr( 1, set(p, con(2))).                 % p = 2;
    line_instr( 2, if(lt(con(1), var(n)), 2)).      % if (n > 1) {
    line_instr( 3, set(p, con(3))).                 %   p = 3;
    line_instr( 4, set(n, sub(var(n), con(1)))).    %   n = n - 1; }
    line_instr( 5, while(lt(con(1), var(n)), 12)).  % while (n > 1):
    line_instr( 6, set(n, sub(var(n), con(1)))).    %   n = n - 1;
    line_instr( 7, set(r, con(0))).                 %   r = 0;
    line_instr( 8, while(le(var(r), con(0)), 8)).   %   while (r <= 0):
    line_instr( 9, set(p, add(var(p), con(2)))).    %     p = p + 2;
    line_instr(10, set(d, con(3))).                 %     d = 3;
    line_instr(11, while(lt(var(d), var(p)), 4)).   %     while (d < p) {
    line_instr(12, set(r, mod(var(p), var(d)))).    %       r = p % d;
    line_instr(13, set(d, add(var(d), con(2)))).    %       d = d + 2;
    line_instr(14, if(le(var(r), con(0)), 1)).      %       if (r <= 0) {
    line_instr(15, set(d, var(p))).                 %         d = p; }
    line_instr(16, end_while).                      %     }
    line_instr(17, end_while).                      %   }
    line_instr(18, end_while).                      % }
\end{Verbatim}

Running this program with the following parameters:
\begin{Verbatim}[samepage=true]
    #const time_max=100.
    #const int_min=0.
    #const int_max=15.
    
    in(run1,n,1).
    in(run2,n,2).
    in(run3,n,3).
    in(run4,n,4).
    in(run5,n,5).
    in(run6,n,6).
\end{Verbatim}
We obtain an answer set containing the following results:
\begin{Verbatim}[samepage=true]
    run_var_out(run1,p,2)
    run_var_out(run2,p,3)
    run_var_out(run3,p,5)
    run_var_out(run4,p,7)
    run_var_out(run5,p,11)
    run_does_not_halt(run6)
\end{Verbatim}
The first 5 runs successfully computed the value we would expect, but 
\verb|run6| failed to halt. This is because the number of time-steps 
needed to count up to the 6th prime number exceeds our value of 
\verb|time_max=100|. It is possible to raise this value and obtain a value 
of $\verb|p|=13$, but at this point the grounding of the ASP becomes large 
enough that extending it to a search of many similar programs of this 
complexity is computationally infeasible when running on current desktop 
machines.

This indicates that a divide-and-conquer approach will be needed in order 
to address more complicated programs. The above program can be seen to 
consist of three main subprograms: the innermost loop, which checks 
whether $\verb|p|\geq3$ is a prime number; the loop containing that, which 
increments a prime number $\verb|p|\geq3$ to the next largest prime 
number; and the outermost loop, which increments $\verb|p|\geq3$ to the 
$(n-1)$th next largest prime number. It is possible to reason separately 
about the correctness of these subprograms, so in the same way it may be 
possible to synthesise them separately.

\chapter{Synthesis of Programs from User Examples} \label{chp:synexm}

This chapter will detail the part of our system which takes a list of user 
examples as input, and gives a program satisfying those examples as 
output. It consists of two components:
\begin{itemize}
    \item An Answer Set Program, \verb|learn.asp|, which contains a 
    modified version of \verb|run.asp| from Section~\ref{sec:runasp}, in 
    addition to aggregrates and integrity constraints which invert the 
    computation done by \verb|run.asp| so that it takes program results as 
    \emph{input}, and produces the program as \emph{output}.

    \item A Haskell program which reads a \emph{task specification} and 
    sets up parameters to \verb|learn.asp|, running it multiple times if 
    necessary with different parameters to find a program meeting the task 
    specification, and prints it in a human-readable form.
\end{itemize}

\section{Task Specification Language} \label{sec:spclng}
The user specifies a program synthesis task by writing a configuration file 
containing the relevant parameters. The format chosen for this file is an 
Answer Set Program whose answer set contains facts giving the parameters. 
Although it is possible to perform computation in this file, the normal usage 
is to simply list the parameters as individual facts; the ASP format was 
chosen for ease of integration with the other tools used.

The following categories of parameters may be given:

\subsection{Input/Output Examples}

\begin{Verbatim}[samepage=true]
input_variable(V1; ...; Vn).
\end{Verbatim}
The \ttt{n} variables $\{\ttt{V1}, ..., \ttt{Vm}\}$ are declared as input 
variables, meaning that they are initialised with values to parameterise an 
individual execution of the program.

\begin{Verbatim}[samepage=true]
output_variable(V1; ...; Vn).
\end{Verbatim}
The \ttt{n} variables $\{\ttt{V1}, ..., \ttt{Vm}\}$ are declared as output
variables, meaning that their values when the program terminates are recorded
and possibly compared with the input values to determine correctness.

\begin{Verbatim}[samepage=true]
 in(ExampleID, InputVariable,  InitialValue).
out(ExampleID, OutputVariable, ExpectedFinalValue).
\end{Verbatim}
These parameters allow the user to list input/output examples that the program 
is required to satisfy. Any number of examples may be given, and each set of 
examples should have a unique \ttt{ExampleID}, with which each 
\ttt{InputVariable} and \ttt{OutputVariable} is associated with an 
\ttt{InitialValue} or \ttt{ExpectedFinalValue}.

\subsection{Language Bias}
\begin{Verbatim}[samepage=true]
constant(C1; ...; Cn).           % Optional; default: no constants.
\end{Verbatim}
The \ttt{n} numerical constants $\{\ttt{C1}, ..., \ttt{Cn}\}$ 
given here may occur as literals in the program. No other constants may occur.

\begin{Verbatim}[samepage=true]
extra_variable(V1; ...; Vn).     % Optional; default: no extra variables.
\end{Verbatim}
The \texttt{n} variables $\{\ttt{V1}, ..., \ttt{Vn}\}$ given here 
may occur in the program in addition to those given by \ttt{input\_variable\/1}
and \ttt{output\_variable\/1}. No other variables may occur.

\begin{Verbatim}[samepage=true]
read_only_variable(V1; ...; Vn). % Optional; default: all variables writable.
\end{Verbatim}
None of the \texttt{n} variables $\{\ttt{V1}, ..., \ttt{Vn}\}$ 
given here may be modified by the program. Of course, this only makes sense 
for input variables, as a read-only variable could only otherwise hold a value 
by receiving an input value. This can be used to speed up the search for a 
program by eliminating spurious variable assignments.

\begin{Verbatim}[samepage=true]
disallow_feature(if).           % No if statements.
disallow_feature(while).        % No while loops.

disallow_feature(add).          % No addition.
disallow_feature(sub).          % No subtraction.
disallow_feature(mul).          % No multiplication.
disallow_feature(div).          % No integer division.
disallow_feature(mod).          % No remainder.
disallow_feature(arithmetic).   % None of the above operations.
\end{Verbatim}
The given syntactic element is prevented from occurring in a generated 
program, unless it occurs in user-specified code in the program template.

\subsection{Program Template}
\begin{Verbatim}[samepage=true]
preset_line_instr(Line, Instr).
preset_line_instr(line_max-N, Instr).
\end{Verbatim}
In the first form, an instruction at a certain line number is fixed, using 
the same format as \verb|line_instr| from Section~\ref{sec:runasp}. In the 
second form, the special constant \verb|line_max|, which is instantiated 
to the number of lines in the program the synthesiser is currently trying 
to generate, is used to specify an instruction \verb|N| lines from the 
end of the program.

\subsection{Execution Limits}
\begin{Verbatim}[samepage=true]
int_range(Imin, Imax).  % Required.
\end{Verbatim}
The value of no variable may be less than \ttt{Imax} or greater than 
\ttt{Imin}.

\begin{Verbatim}[samepage=true]
time_limit(Tmax).       % Required.
\end{Verbatim}
No more than \ttt{Tmax} instructions may be executed in any single execution.

\subsection{Search Hints}
\begin{Verbatim}[samepage=true]
line_limit_min(Lmin).   % Optional; default: 0.
line_limit_max(Lmax).   % Optional; default: unbounded.
line_limit_step(Lstep). % Optional; default: 1.
\end{Verbatim}
Controls the incremental search for a program with increasing limits on 
the number of lines. Initially, a program with \ttt{Lmin} lines is sought 
(for the default, \verb|Lmin=0|, this is the empty program). If no such 
program can be found, the limit is increased by \ttt{Lstep} and the search 
repeated, until the limit exceeds \ttt{Lmax}.

\section{Implementation}


\section{Examples}
Below is an example of how we might use this language to specify a program 
which takes an input $x_0$, and produces an output with $y = 2^{x_0}$, by 
listing a number of input/output examples. We make a guess at the 
execution resources and the language elements needed by the resulting 
program.

\begin{Verbatim}[samepage=true]
    int_range(0, 32).
    time_limit(10).
    constant(1; 2).

    input_variable(x).
    output_variable(y).

    in(ex0, x, 0). out(ex0, y, 1).
    in(ex1, x, 1). out(ex1, y, 2).
    in(ex2, x, 2). out(ex2, y, 4).
    in(ex3, x, 3). out(ex3, y, 8).
    in(ex4, x, 4). out(ex4, y, 16).
    in(ex5, x, 5). out(ex5, y, 32).
\end{Verbatim}

\chapter{Automatic Generation of Examples} \label{chp:genexm}

\section{Extensions to the Task Specification Language}
The specification language from Chapter~\ref{chp:synexm} is extended with 
the following configuration entries:

\subsection{Functional Specification}

\begin{Verbatim}[samepage=true]
precondition(PreconditionString).   % Optional; default: true.
postcondition(PostconditionString). % Optional; default: true.
\end{Verbatim}
If a precondition and/or postcondition are given, the task is to synthesise a 
program whose output values satisfy the postcondition whenever its input 
values satisfy the precondition, in addition to any constraints given by 
input/output examples.

Preconditions and postconditions are given as ASP \verb|"strings"|
containing propositional formulae written in the same syntax as the body of an 
ASP rule. Preconditions may contain no ASP variables other than those 
corresponding to the initial values of input variables, which take the form 
\ttt{In\_x} for an input variable named \ttt{x}. Postconditions may contain 
the same ASP variables, in addition to those corresponding to the final values 
of output variables, which take the form \ttt{Out\_y} for an output variable 
named \ttt{y}.

\section{Implementation}

\section{Examples}

In Chapter~\ref{chp:synexm} we gave an example of how we would specify 
using a list of the examples the $y = 2^{x_0}$ program. We now show how, 
using the extensions to specification language, this can be done with no 
explicitly listed examples:

\begin{Verbatim}[samepage=true]
    int_range(0, 32).
    time_limit(10).
    constant(1; 2).    

    input_variable(x).
    output_variable(y).

    precondition("In_x >= 0").
    postcondition("Out_y == 2 ** In_x").
\end{Verbatim}

\chapter{Separate Synthesis of Subprograms} \label{chp:gensub}
\section{Extensions to the Task Specification Language}
\section{Separate Synthesis of Loop Bodies}

\chapter{Evaluation}
\section{Power and Accuracy}
\subsection{Extent of Capabilities}
\subsection{Correctness of Generated Programs}
\section{Efficiency}
\subsection{Time and Space Usage}
\subsection{Number of Examples Needed}
\subsection{Quality of Generated Programs}
\section{Comparison with Existing Systems}

\chapter{Conclusions and Future Work}
\section{Conclusion}
\section{Possible Extensions}

\begin{thebibliography}{9}
    \bibitem{fortran}
        Padua, D. (2000). The Fortran I Compiler.
        \emph{Computing in Science \& Engineering}, 2(1), 70-75.
        \url{http://www.cs.fsu.edu/~lacher/courses/CIS49301/notes/cise_v2_i1/fortran.pdf}
    \bibitem{cheatham86}
        Cheatham, T. E. (1986). Reusability through program transformations. 
        \emph{Readings in Artificial Intelligence and Software Engineering}, 
        edited by C. Rich and RC Waters, 185-190.
    \bibitem{goldberg86}
        Goldberg, A. T. (1986). Knowledge-based programming:
        A survey of program design and construction techniques.
        \emph{Software Engineering, IEEE Transactions on}, (7), 752-768.
    \bibitem{bundy90}
        Bundy, A., Smaill, A., Wiggins, G. (1990, January).
        The synthesis of logic programs from inductive proofs.
        In \emph{Computational Logic} (pp. 135-149). Springer Berlin Heidelberg.
    \bibitem{deville94}
        Deville, Y., Lau, K. K. (1994). Logic program synthesis.
        \emph{The Journal of Logic Programming}, 19, 321-350.
    \bibitem{flener97}
        Flener, P., Lau, K. K., Ornaghi, M. (1997, November). 
        Correct-schema-guided synthesis of steadfast programs.
        In \emph{Automated Software Engineering, 1997.
        Proceedings., 12th IEEE International Conference} (pp. 153-160). IEEE.
    \bibitem{basin04}
        Basin, D., Deville, Y., Flener, P., Hamfelt, A., Nilsson, J. F. (2004).
        Synthesis of programs in computational logic.
        In \emph{Program Development in Computational Logic} (pp. 30-65).
        Springer Berlin Heidelberg.
    \bibitem{colon05}
        Colón, M. A. (2005). Schema-guided synthesis of imperative programs by 
        constraint solving. In \emph{Logic Based Program Synthesis and 
        Transformation} (pp. 166-181). Springer Berlin Heidelberg.
    \bibitem{popl10syn}
        Srivastava, S., Gulwani, S., Foster, J. S. (2010).
        From Program Verification to Program Synthesis.
        \url{http://www.cs.umd.edu/~saurabhs/pubs/popl10-syn.html}
    \bibitem{tds}
        Perelman, D., Gulwani, S., Grossman, D., Provost, P. (2014).
        Test-Driven Synthesis.
        \url{http://research.microsoft.com/en-us/um/people/sumitg/pubs/pldi14-tds.pdf}
    \bibitem{potassco}
        Potassco, the Potsdam Answer Set Solving Collection.
        \url{http://potassco.sourceforge.net}
    \bibitem{glimpse}
        Anger, C., Konczak, K., Linke, T., Schaub, T. (2005).
        A Glimpse of Answer Set Programming.
        \url{http://www.cs.uni-potsdam.de/wv/pdfformat/ankolisc05.pdf}
    \bibitem{aspal}
        Corapi, D., Russo, A., Lupu, E. (2011).
        Inductive Logic Programming in Answer Set Programming.
        \url{http://ilp11.doc.ic.ac.uk/short_papers/ilp2011_submission_20.pdf}
    \bibitem{ilasp}
        Law, M., Russo, A., Broda, K. (2014).
        Inductive learning of answer set programs.
        \url{https://www.doc.ic.ac.uk/~ml1909/ILASP_Paper.pdf}
\end{thebibliography}

\end{document}
